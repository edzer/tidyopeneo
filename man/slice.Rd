% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/slice.R
\name{slice}
\alias{slice}
\alias{slice.datacube}
\title{Slice Datacube}
\usage{
\method{slice}{datacube}(
  .data = NULL,
  ...,
  .extent = NULL,
  .dimension = NULL,
  .geometries = NULL,
  .condition = NULL,
  .context = NULL
)
}
\arguments{
\item{.data}{datacube object from tidyopeneo. For
array_filter : an array.}

\item{...}{any parameter inherited from dplyr}

\item{.extent}{For **filter_temporal**, the Left-closed temporal interval, i.e.
an array with exactly two elements: The first element is the start of the
temporal interval. The specified instance in time is **included** in the
interval. The second element is the end of the temporal interval. The
specified instance in time is **excluded** from the interval. The specified
temporal strings follow [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html).
Also supports open intervals by setting one of the boundaries to `null`, but
never both.
For **filter_bbox**, the bounding box, which may include a vertical axis
(see `base` and `height`).}

\item{.dimension}{For **filter_temporal** : The name of the temporal dimension
to filter on. If no specific dimension is specified or it is set to `null`,
the filter applies to all temporal dimensions. Fails with a `DimensionNotAvailable`
exception if the specified dimension does not exist.}

\item{.geometries}{For **filter_spatial** : one or more geometries used for
filtering, specified as GeoJSON.}

\item{.condition}{For **array_filter** : A condition that is evaluated against
each value, index and/or label in the array. Only the array elements for
which the condition returns `true` are preserved.}

\item{.context}{For **array_filter** (optional): Additional data to be passed to the condition.}
}
\value{
datacube
}
\description{
Slice datacube wraps the filter_temporal, filter_bbox,
filter_spatial and array_filter functions into a simulated dplyr's \code{\link[dplyr]{slice}}.
}
\details{
if arg extent is defined as a length two vector, filter_temporal is
gonna be called. If it has length of four, filter_bbox is gonna be called.
In case the argument geometries is defined, filter_spatial is gonna run, and,
finally, if .data is an array, array_filter will be wrapped.
}
\examples{
library(tidyopeneo)
library(sf)

dc = datacube(id = "SENTINEL_5P_L2")

# filter_temporal and filter_bbox
dc = dc \%>\%
    slice(.extent = c("2021-01-01", "2021-03-03")) \%>\%
    slice(.extent = c(west = 6.09, east = 6.99, south = 46.15, north = 46.57))

# filter_spatial
lon = c(6.22, 6.24)
lat = c(46.20, 46.25)
pol_coords = dplyr::tibble(lon, lat)
pol <- pol_coords \%>\%
    st_as_sf(coords = c("lon", "lat"), crs = 3857) \%>\%
    st_bbox() \%>\%
    st_as_sfc()

dc = dc \%>\% slice(.geometries = pol)

# array_filter
# ToDO...
}
\seealso{
[openeo::list_processes()]
}
